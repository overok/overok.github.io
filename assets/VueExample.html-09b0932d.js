import{_ as a,o as e,c as t,b as p,t as o,a as n}from"./app-dc634640.js";const c={},i=n(`<h1 id="vue-例题" tabindex="-1"><a class="header-anchor" href="#vue-例题" aria-hidden="true">#</a> Vue 例题</h1><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span> 
	<span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
		<span class="token literal-property property">users</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token keyword">async</span> <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;/api/users&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token keyword">this</span><span class="token punctuation">.</span>users <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容</span>
<span class="token operator">&lt;</span>recycle<span class="token operator">-</span>scroller <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;items&quot;</span> <span class="token operator">:</span>items<span class="token operator">=</span><span class="token string">&quot;items&quot;</span> <span class="token operator">:</span>item<span class="token operator">-</span>size<span class="token operator">=</span><span class="token string">&quot;24&quot;</span><span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>template v<span class="token operator">-</span>slot<span class="token operator">=</span><span class="token string">&quot;{ item }&quot;</span><span class="token operator">&gt;</span>
 		<span class="token operator">&lt;</span>FetchItemView <span class="token operator">:</span>item<span class="token operator">=</span><span class="token string">&quot;item&quot;</span> @vote<span class="token operator">=</span><span class="token string">&quot;voteItem(item)&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>recycle<span class="token operator">-</span>scroller<span class="token operator">&gt;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="什么是-mixin" tabindex="-1"><a class="header-anchor" href="#什么是-mixin" aria-hidden="true">#</a> 什么是 mixin ？</h2><p>● Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</p><p>● 如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</p><p>● 然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</p><h2 id="vue中mixin与extend区别" tabindex="-1"><a class="header-anchor" href="#vue中mixin与extend区别" aria-hidden="true">#</a> vue中mixin与extend区别</h2><p>全局注册混合对象，会影响到所有之后创建的vue实例，而Vue.extend是对单个实例进行扩展。</p><h2 id="vue中provide和inject-用法" tabindex="-1"><a class="header-anchor" href="#vue中provide和inject-用法" aria-hidden="true">#</a> Vue中provide和inject 用法</h2><p>provide和inject是成对出现的<br> 作用：用于父组件向子孙组件传递数据</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//父组件定义：</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// 父组件通过provide将自己的数据以对象形式传出去</span>
  <span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">parentValue</span><span class="token operator">:</span><span class="token string">&quot;我是父组件的值啊&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//子孙组件接受方式：</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// inject:[&quot;parentValue&quot;], // 使用一个注入的值作为数据入口：</span>
  <span class="token literal-property property">inject</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token comment">// 使用一个默认值使其变成可选项</span>
    <span class="token literal-property property">parentValue</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// 健名</span>
      <span class="token literal-property property">from</span><span class="token operator">:</span> <span class="token string">&#39;parentValue&#39;</span><span class="token punctuation">,</span> <span class="token comment">// 来源</span>
      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token string">&#39;parentValue&#39;</span> <span class="token comment">// 默认值</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//注意：provide并不是响应式的，当子组件inject的时候已经丢失了响应式功能</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="vue-中的-computed-是如何实现的" tabindex="-1"><a class="header-anchor" href="#vue-中的-computed-是如何实现的" aria-hidden="true">#</a> Vue 中的 computed 是如何实现的</h2><p>实质是一个惰性的watcher，在取值操作时根据自身标记 dirty属性返回上一次计算结果/重新计算值 在创建时就进行一次取值操作，收集依赖变动的对象/属性(将自身压入dep中) 在依赖的对象/属性变动时，仅将自身标记dirty致为true</p><h2 id="vue初始化页面闪动问题" tabindex="-1"><a class="header-anchor" href="#vue初始化页面闪动问题" aria-hidden="true">#</a> vue初始化页面闪动问题</h2>`,14),l=n(`<p>解决<code>[v-cloak] {display: none;}</code>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;{display: &#39;block&#39;}&quot;</code></p><h2 id="vue模版编译原理" tabindex="-1"><a class="header-anchor" href="#vue模版编译原理" aria-hidden="true">#</a> Vue模版编译原理</h2><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p><p>● 解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</p><p>● 优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</p><p>● 生成阶段：将最终的AST转化为render函数字符串。</p><h2 id="nexttick" tabindex="-1"><a class="header-anchor" href="#nexttick" aria-hidden="true">#</a> NextTick</h2><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p><p>nextTick是Vue提供的一个全局API,是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM；</p><p><code>nextTick的实现原理是什么？</code></p><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate， 如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><h2 id="keep-alive的实现" tabindex="-1"><a class="header-anchor" href="#keep-alive的实现" aria-hidden="true">#</a> keep-alive的实现</h2><p><code>原理：</code>Vue.js内部将DOM节点抽象成了一个个的VNode节点，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（pruneCache与pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。</p><div class="language-javaScript line-numbers-mode" data-ext="javaScript"><pre class="language-javaScript"><code>//include定义缓存白名单，keep-alive会缓存命中的组件；
//exclude定义缓存黑名单，被命中的组件将不会被缓存；
//max定义缓存组件上限，超出上限使用LRU的策略置换缓存数据。 
&lt;keep-alive :include=&quot;whiteList&quot; :exclude=&quot;blackList&quot; :max=&quot;amount&quot;&gt;
     &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt; //在动态组件中的应用
     &lt;router-view&gt;&lt;/router-view&gt; //在vue-router中的应用 
&lt;/keep-alive&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="route和-router-的区别" tabindex="-1"><a class="header-anchor" href="#route和-router-的区别" aria-hidden="true">#</a> $route和$router 的区别</h2><p>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。 而$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等</p><h2 id="vue-router-导航守卫" tabindex="-1"><a class="header-anchor" href="#vue-router-导航守卫" aria-hidden="true">#</a> vue-router 导航守卫</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//-全局守卫</span>
<span class="token comment">// main.js 入口文件</span>
<span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">&#39;./router&#39;</span>
router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
router<span class="token punctuation">.</span><span class="token function">beforeResolve</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;afterEach 全局后置钩子&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//-路由独享守卫</span>
<span class="token comment">//如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫</span>
<span class="token keyword">const</span> router <span class="token operator">=</span>
  <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/foo&#39;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">component</span><span class="token operator">:</span> Foo<span class="token punctuation">,</span>
        <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token comment">// 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖</span>
          <span class="token comment">// ...</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//路由组件内的守卫</span>
beforeRouteEnter 进入路由前<span class="token punctuation">,</span> 在路由独享守卫后调用 不能 获取组件实例 <span class="token keyword">this</span>，组件实例还没被创建
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="vue-底层实现原理" tabindex="-1"><a class="header-anchor" href="#vue-底层实现原理" aria-hidden="true">#</a> Vue 底层实现原理</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>
<span class="token operator">-</span> Vue 的响应式原理
  核心是通过 <span class="token constant">ES5</span> 的保护对象的 Object<span class="token punctuation">.</span>defindeProperty 中的访问器属性中的 <span class="token keyword">get</span> 和 <span class="token keyword">set</span> 方法，
  data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 <span class="token keyword">get</span> 方法，当修改 data
  中的数据时，自动调用 <span class="token keyword">set</span> 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher 自动触
  发重新 render 当前组件（子组件不会重新渲染）<span class="token punctuation">,</span>生成新的虚拟 <span class="token constant">DOM</span> 树，Vue 框架会遍历并对比新虚拟
  <span class="token constant">DOM</span> 树和旧虚拟 <span class="token constant">DOM</span> 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修
  改到真实 <span class="token constant">DOM</span> 树上。

<span class="token comment">//Object.defineProperty缺点</span>
<span class="token number">1.</span> 不能监听数组的变化
<span class="token number">2.</span> 必须遍历对象的每个属性
<span class="token number">3.</span> 必须深层遍历嵌套的对象
<span class="token number">4.</span> Object<span class="token punctuation">.</span>defineProperty 只能监听到属性的读写
<span class="token comment">//虽然 Vue 中确实能检测到数组数据的变化，但是其实是使⽤了 hack 的办法，并且也是有缺陷的。</span>
<span class="token comment">// hack 以下⼏个函数,通过函数方法来监听数组的</span>
<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
 <span class="token string">&#39;push&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;pop&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;shift&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;unshift&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;splice&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;sort&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;reverse&#39;</span>
<span class="token punctuation">]</span>
<span class="token comment">//Proxy 优势：</span>
<span class="token number">1.</span> 针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。
<span class="token number">2.</span> Proxy 不需要对数组的方法进行重载，省去了众多 hack。
<span class="token number">3.</span> Proxy 的第二个参数可以有 <span class="token number">13</span> 种拦截方法
<span class="token number">4.</span> Proxy 除读写外还可以监听属性的删除，方法的调用等
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="vuex" tabindex="-1"><a class="header-anchor" href="#vuex" aria-hidden="true">#</a> Vuex</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>有五种，分别是 State、 Getter、Mutation 、Action、 Module
<span class="token number">1</span>、state <span class="token operator">=&gt;</span> <span class="token function">基本数据</span><span class="token punctuation">(</span>数据源存放地<span class="token punctuation">)</span>
<span class="token number">2</span>、getters <span class="token operator">=&gt;</span> 从基本数据派生出来的数据
<span class="token number">3</span>、mutations <span class="token operator">=&gt;</span> 提交更改数据的方法，同步
<span class="token number">4</span>、actions <span class="token operator">=&gt;</span> 像一个装饰器，包裹mutations，使之可以异步。
<span class="token number">5</span>、modules <span class="token operator">=&gt;</span> 模块化Vuex

<span class="token number">1</span>、Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。
<span class="token number">2</span>、每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time<span class="token operator">-</span>travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="父子组件生命周期" tabindex="-1"><a class="header-anchor" href="#父子组件生命周期" aria-hidden="true">#</a> 父子组件生命周期？</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//加载渲染过程</span>
父beforeCreate <span class="token operator">-</span><span class="token operator">&gt;</span> 父created <span class="token operator">-</span><span class="token operator">&gt;</span> 父beforeMount <span class="token operator">-</span><span class="token operator">&gt;</span> 子beforeCreate
<span class="token operator">-</span><span class="token operator">&gt;</span> 子created <span class="token operator">-</span><span class="token operator">&gt;</span>子beforeMount <span class="token operator">-</span><span class="token operator">&gt;</span> 子mounted <span class="token operator">-</span><span class="token operator">&gt;</span> 父mounted
<span class="token comment">//子组件更新过程</span>
父beforeUpdate <span class="token operator">-</span><span class="token operator">&gt;</span> 子beforeUpdate <span class="token operator">-</span><span class="token operator">&gt;</span> 子updaed <span class="token operator">-</span><span class="token operator">&gt;</span> 父updated
<span class="token comment">//父组件跟新过程</span>
父beforeUpdate <span class="token operator">-</span><span class="token operator">&gt;</span> 父updated
<span class="token comment">//销毁过程</span>
父beforeDestroy <span class="token operator">-</span><span class="token operator">&gt;</span> 子beforeDestroy <span class="token operator">-</span><span class="token operator">&gt;</span> 子destroyed <span class="token operator">-</span><span class="token operator">&gt;</span>父destroyed
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="vue-组价的-data-为什么必须是个函数-而根实例则没有此限制" tabindex="-1"><a class="header-anchor" href="#vue-组价的-data-为什么必须是个函数-而根实例则没有此限制" aria-hidden="true">#</a> Vue 组价的 data 为什么必须是个函数？⽽根实例则没有此限制？</h2><ul><li>1.Vue 组件可能存在对个实例，如果使⽤对象形式定义 data，则会导致它们共⽤⼀个 data 对象，那么状态变更将会影响所有组件实例，有效规避多实例之间状态污染问题。</li><li>2.⽽在 Vue 根实例创建过程中则不存在该限制，是因为根实例只能有⼀个，不需要担⼼这种情况。</li></ul><h2 id="谈谈你对-vue-的双向数据绑定原理的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-vue-的双向数据绑定原理的理解" aria-hidden="true">#</a> 谈谈你对 vue 的双向数据绑定原理的理解</h2><ul><li>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</li><li>第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</li><li>第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li>第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</li><li><ul><li>1、在自身实例化时往属性订阅器(dep)里面添加自己</li></ul></li><li><ul><li>2、自身必须有一个 update()方法</li></ul></li><li><ul><li>3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。</li></ul></li><li>第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</li><li>简而言之，就是先转化成 AST 树，再得到的 render 函数返回 VNode（Vue 的虚拟 DOM 节点）</li></ul><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h2><p><code>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是 Vue 的⽣命周期。</code></p><p><code>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。Vue 提供了\\$set 方法用来触发视图更新</code></p><p><code>第一次页面加载会触发哪些钩子 beforeCreate、created、beforeMount、mounted</code></p><p><code>生命周期第一个阶段——初始化阶段中所做的第一件事：new Vue(),首先，分析了 new Vue()时其内部都干了些什么。其主要逻辑就是：合并配置，调用一些初始化函数，触发生命周期钩子函数，调用\\$mount 开启下一个阶段。</code></p><ul><li>1、beforeCreate（创建前） ：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到 data、computed、watch、methods 上的方法和数据。</li><li>2、created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是真实 dom 还没有生成，所以不能访问到 <code>$el</code> 属性。</li><li>3、beforeMount（挂载前） ：在挂载开始之前被调用，相关的 render 函数首次被调用。实例已完成以下的配置：编译模板，把 data 里面的数据和模板生成 html。此时还没有挂载 html 到页面上。</li><li>4、mounted（挂载后） ：在 el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的 html 内容替换 el 属性指向的 DOM 对象。完成模板中的 html 渲染到 html 页面中。此过程中进行 ajax 交互。</li><li>5、beforeUpdate（更新前） ：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li><li>6、updated（更新后）：在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li>7、beforeDestroy（销毁前） ：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li><li>8、destroyed（销毁后） ：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li></ul><h2 id="vite-config-ts" tabindex="-1"><a class="header-anchor" href="#vite-config-ts" aria-hidden="true">#</a> vite.config.ts</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vite&#39;</span>
<span class="token keyword">import</span> vue <span class="token keyword">from</span> <span class="token string">&#39;@vitejs/plugin-vue&#39;</span>
<span class="token keyword">import</span> path <span class="token keyword">from</span> <span class="token string">&#39;path&#39;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">base</span><span class="token operator">:</span> <span class="token string">&#39;./&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">resolve</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">alias</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果报错__dirname找不到，需要安装node,执行npm install @types/node --save-dev</span>
      <span class="token string-property property">&#39;@&#39;</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&#39;./src&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token string-property property">&#39;@assets&#39;</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&#39;./src/assets&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token string-property property">&#39;@components&#39;</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&#39;./src/components&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token string-property property">&#39;@views&#39;</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&#39;./src/views&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token string-property property">&#39;@store&#39;</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&#39;./src/store&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">build</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">outDir</span><span class="token operator">:</span> <span class="token string">&#39;dist&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">server</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">https</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 是否开启 https</span>
    <span class="token literal-property property">open</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 是否自动在浏览器打开</span>
    <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token number">8001</span><span class="token punctuation">,</span> <span class="token comment">// 端口号</span>
    <span class="token literal-property property">host</span><span class="token operator">:</span> <span class="token string">&#39;0.0.0.0&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string-property property">&#39;/api&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">target</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span> <span class="token comment">// 后台接口</span>
        <span class="token literal-property property">changeOrigin</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token literal-property property">secure</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 如果是https接口，需要配置这个参数</span>
        <span class="token comment">// ws: true, //websocket支持</span>
        <span class="token function-variable function">rewrite</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> path<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\\/api</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 引入第三方的配置</span>
  <span class="token literal-property property">optimizeDeps</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">include</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,36);function r(s,u){return e(),t("div",null,[i,p("p",null,"使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于"+o(s.message)+"的字样.",1),l])}const k=a(c,[["render",r],["__file","VueExample.html.vue"]]);export{k as default};
